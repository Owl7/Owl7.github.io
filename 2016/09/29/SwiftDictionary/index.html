<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Dictionary基础知识定义Dictionary假设我们要定义一个数据结构，用来保存用户在某个视频的观看情况。可以这样： enum RecordType {     case bool(Bool)     case number(Int)     case text(String) }  let record11: [String: RecordType] = [     &amp;quot;uid&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 中的 Dictionary">
<meta property="og:url" content="http://yoursite.com/2016/09/29/SwiftDictionary/index.html">
<meta property="og:site_name" content="Owl&#39;s blog">
<meta property="og:description" content="Dictionary基础知识定义Dictionary假设我们要定义一个数据结构，用来保存用户在某个视频的观看情况。可以这样： enum RecordType {     case bool(Bool)     case number(Int)     case text(String) }  let record11: [String: RecordType] = [     &amp;quot;uid&amp;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-20T02:19:26.380Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 中的 Dictionary">
<meta name="twitter:description" content="Dictionary基础知识定义Dictionary假设我们要定义一个数据结构，用来保存用户在某个视频的观看情况。可以这样： enum RecordType {     case bool(Bool)     case number(Int)     case text(String) }  let record11: [String: RecordType] = [     &amp;quot;uid&amp;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/09/29/SwiftDictionary/"/>





  <title>Swift 中的 Dictionary | Owl's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Owl's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/29/SwiftDictionary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pengyw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Owl's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Swift 中的 Dictionary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-29T14:59:25+08:00">
                2016-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Dictionary基础知识"><a href="#Dictionary基础知识" class="headerlink" title="Dictionary基础知识"></a>Dictionary基础知识</h3><h4 id="定义Dictionary"><a href="#定义Dictionary" class="headerlink" title="定义Dictionary"></a>定义Dictionary</h4><p>假设我们要定义一个数据结构，用来保存用户在某个视频的观看情况。可以这样：</p>
<pre><code>enum RecordType {
    case bool(Bool)
    case number(Int)
    case text(String)
}

let record11: [String: RecordType] = [
    &quot;uid&quot;: .number(11),
    &quot;exp&quot;: .number(100),
    &quot;favourite&quot;: .bool(true),
    &quot;title&quot;: .text(&quot;Dictionary basics&quot;)
]
</code></pre><p>在上面代码里，我们用[KeyType: ValueType]的形式来定义一个Dictionary。当定义好Dictionary之后，我们就能直接用[Key]来访问某个key对应的值了：</p>
<pre><code>record11[&quot;uid&quot;]       // number(11)
record11[&quot;favourite&quot;] // bool(true)
record11[&quot;title&quot;]     // text(&quot;Dictionary basics&quot;)
record11[&quot;invalid&quot;]   // nil

// Optional&lt;RecordType&gt;.Type
type(of: record11[&quot;favourite&quot;])
</code></pre><p>你怎么理解这种差异呢？</p>
<p>这是因为索引这个概念，对Array和Dictionary来说，是截然不同的。对于Array来说，我们有可能使用的正常索引值只源于Array自身，也就是0..&lt;array.count，因此，如果你使用了不在这个范围里的值，则一定是可以被定性为Bug的，何况，我们之前也看到了，对于Array，我们几乎不需要直接使用索引来访问元素。</p>
<p>而对于Dictionary来说，它包含的内容并不直接决定我们可以查询的内容。举个例子来说，英汉词典中也可能并不包含我们要查询的单词。所以，Dictionary中包含的所有键值，从语义上说，并不完全决定了它的使用者会查询的值，所以，我们也无法把这类问题明确的归因于是Bug。所以，Swfit为Dictionary的索引查询操作，提供了optional保护。要么得到正确的结果，要么通过nil表示要查询的内容不存在。</p>
<h4 id="常用的基本属性"><a href="#常用的基本属性" class="headerlink" title="常用的基本属性"></a>常用的基本属性</h4><p>作为一个集合类型，Dictionary同样有count和isEmpty两个属性读取其元素的个数以及判断其是否为空：</p>
<pre><code>record11.count   // 4
record11.isEmpty // false
</code></pre><p>另外，我们可以单独访问一个Dictionary的所有keys和所有values：</p>
<pre><code>record11.keys
record11.values
</code></pre><p>这两个属性也分别是一个集合，我们可以暂时忽略掉它们具体的类型，如果要我们要访问它们的每一个元素，直接用for循环或forEach遍历就好了：</p>
<pre><code>for key in record11.keys { print(key) }
// or
record11.keys.forEach { print($0) }
</code></pre><h4 id="添加、更新和删除元素"><a href="#添加、更新和删除元素" class="headerlink" title="添加、更新和删除元素"></a>添加、更新和删除元素</h4><p>和Array一样，Dictionary也是一个值类型，当我们复制Dictionary对象的时候，就会拷贝Dictionary中的所有内容：</p>
<pre><code>var record10 = record11
</code></pre><p>并且，直接使用key就可以访问和修改Dictionary的内容：</p>
<pre><code>record10[&apos;favourite&apos;] = .bool(false) // false
record11[&apos;favourite&apos;] // true
</code></pre><p>如果我们希望更新value的时候，同时获得修改前的值，还可以使用updateValue(_:forKey:)方法：</p>
<pre><code>record10.updateValue(.bool(true), forKey: &quot;favourite&quot;) // .bool(false)
</code></pre><p>从上面的结果可以看出修改record10并不会影响record11。</p>
<p>当我们要在Dictionary中添加元素时，直接给要添加的key赋值就好了：</p>
<pre><code>record10[&quot;watchLater&quot;] = .bool(false)
// [
//  &quot;favourite&quot;: RecordType.bool(false),
//  &quot;exp&quot;: RecordType.number(100),
//  &quot;title&quot;: RecordType.text(&quot;Directory basics&quot;),
//  &quot;uid&quot;: RecordType.number(11),
//  &quot;watchLater&quot;: RecordType.bool(false)
// ]
</code></pre><p>这样，record10中的内容，就变成了5项。而当我们要删除特定的key时，直接把它的值设置为nil：</p>
<pre><code>record10[&quot;watchLater&quot;] = nil
// [
//  &quot;favourite&quot;: RecordType.bool(false),
//  &quot;exp&quot;: RecordType.number(100),
//  &quot;title&quot;: RecordType.text(&quot;Directory basics&quot;),
//  &quot;uid&quot;: RecordType.number(11)
// ]
</code></pre><p>这里，并不是把特定key的值设置为nil（毕竟Dictionary中value部分的类型也不是optional），而是删除特定的key。当某个key的value被设置成nil后，这个key也就从Dictionary中删除了。</p>
<h4 id="遍历Dictionary"><a href="#遍历Dictionary" class="headerlink" title="遍历Dictionary"></a>遍历Dictionary</h4><p>由于Dictionary同时包含了key和value，因此，我们也有多重方式来遍历Dictionary。最简单的，就是遍历Dictionary中的每一个元素：</p>
<pre><code>for (k, v) in record10 {
    print(&quot;\(k): \(v)&quot;)
}
record10.forEach { print(&quot;\($0): \($1)&quot;) }
</code></pre><p>从上面的例子可以看到，遍历Dictionary和遍历Array是类似的。当我们使用for循环遍历时，它的每一个元素都用一个tuple来表示，封装了每一个元素的key和value。而当使用forEach方法时，它会给它的closure参数传递两个值，分别是每一个元素的key和value。</p>
<p>但是，由于Dictionary是一个无序集合（unordered collection），因此当我们编辑了Dictionary之后，每次遍历，访问元素的顺序都可能是不同的。如果我们希望按照固定的顺序来访问Dictionary中的元素，一个最简单的办法，就是对key排序后，再进行遍历：</p>
<pre><code>for key in record10.keys.sorted() {
    print(&quot;\(key): \(record10[key])&quot;)
}
</code></pre><h3 id="常用的Dictionary-extension"><a href="#常用的Dictionary-extension" class="headerlink" title="常用的Dictionary extension"></a>常用的Dictionary extension</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>然而，该如何实现这个merge呢？最重要的事情，就是要想一下什么内容可以被merge进来。最一般的情况来说，<strong>无论任何形式的序列，只要它的元素中key和value的类型和Dictionary相同，就可以进行合并</strong>。</p>
<p>如何在代码中表达这个特征呢？来看下面的例子：</p>
<pre><code>extension Dictionary {
    mutating func merge&lt;S:Sequence&gt;(_ sequence: S)
        where S.Iterator.Element == (key: Key, value: Value) {
        sequence.forEach { self[$0] = $1 }
    }
}
</code></pre><p>由于Dictionary是一个struct，并且merge修改了self，我们必须使用mutating关键字修饰这个方法。而对于sequence参数，我们通过where关键字限定了两个内容：</p>
<blockquote>
<ul>
<li>S必须遵从Sequence protocol，Dictionary是众多遵从了Sequence protocol的collection类型之一，但是，我们没必要一定只能合并Dictionary；</li>
<li>S的元素类型必须和原Dictionary的Element相同，其中Key和Value是Dictionary声明中的两个反省参数；</li>
</ul>
</blockquote>
<p>解决了参数问题之后，实现合并的算法就很简单了，我们只是更新self中每一个和sequence有相同key的值就好了。</p>
<p>这样，之前template.merge(record11Patch)就可以正常工作了。</p>
<p>既然，我们把merge参数的约束定义为了Sequence，那我们就来看一个合并非Dictionary类型的情况，例如，合并一个包含正确内容的Array：</p>
<p>let record10Patch: [(key: String, value: RecordType)] = [<br>        (key: “uid”,   value: .number(10)),<br>        (key: “title”, value: .text(“Common dictionary extensions”))<br>    ]</p>
<pre><code>var template1 = defaultRecord
template1.merge(record10Patch)
// [
//    uid: .number(10),
//    &quot;exp&quot;: .number(100),
//    &quot;favourite&quot;: .bool(false),
//    &quot;title&quot;: .text(&quot;Common dictionary extensions&quot;)
// ]
</code></pre><p>在上面的代码里，我们合并了一个tuple数组，它的类型是Array&lt;String, RecordType&gt;，数组中的每一项都包含了一个要合并进来的键值对。如果没有意外，合并Array和Dictionary都应该是可以正常工作的。</p>
<p>按照我们对merge的实现方式，实际上，任何一个遵从了Sequence protocol的类型，只要它包含了和template相同的元素类型，都是可以merge的。</p>
<h4 id="用一个tuple数组初始化Dictionary"><a href="#用一个tuple数组初始化Dictionary" class="headerlink" title="用一个tuple数组初始化Dictionary"></a>用一个tuple数组初始化Dictionary</h4><p>理解了merge的实现和用法之后，其实，我们很容易把这个场景进一步扩展下，如果我们可以merge类型兼容的Sequence，那么，用这样的Sequence来初始化一个Dictionary也是可以的，把它看成是和一个空的Dictionary进行合并就好了：</p>
<pre><code>extension Dictionary {
    init&lt;S:Sequence&gt;(_ sequence: S)
        where S.Iterator.Element == (key: Key, value: Value) {

        self = [:]
        self.merge(sequence)
    }
}
</code></pre><p>有了这个方法之后，我们直接用下面的代码就可以创建一个新的Dictionary对象：</p>
<pre><code>let record11 = Dictionary(record11Patch)
// [
//    uid: .number(11),
//    &quot;title&quot;: .text(&quot;Common dictionary extensions&quot;)
// ]
</code></pre><h4 id="定制map的行为"><a href="#定制map的行为" class="headerlink" title="定制map的行为"></a>定制map的行为</h4><p>最后一个要介绍的常用功能，是定制Dictionary.map的行为，默认情况下它返回的是一个Array，例如：</p>
<pre><code>record11.map { $1 }
// [ .number(11).text(&quot;Common dictionary extensions&quot;)]
</code></pre><p>在上面的例子里，map返回一个Array<recordtype>，但有时，我们仅仅希望对value做一些变换，而仍旧保持Dictionary的类型。为此，我们可以自定义一个“只map value”的方法：</recordtype></p>
<pre><code>extension Dictionary {
    func mapValue&lt;T&gt;(_ transform: (Value) -&gt; T) -&gt; [Key: T] {
        return Dictionary&lt;Key, T&gt;(map { (k, v) in
            return (k, transform(v))
        })
    }
}
</code></pre><p>在这个实现的最内部，我们用标准库中的map得到了一个Array&lt;(String, RecordType)&gt;类型的Array，而后，由于Array也遵从了Sequence protocol，因此，我们就能直接使用这个Array来定义新的Dictionary了。</p>
<p>完成之后，用下面的代码测试下：</p>
<pre><code>let newRecord11 = record11.mapValue { record -&gt; String in
    switch record {
    case .text(let title):
        return title
    case .number(let exp):
        return String(exp)
    case .bool(let favourite):
        return String(favourite)
    }
}

// [
//    &quot;uid&quot;: &quot;11&quot;,
//    &quot;title&quot;: &quot;Common dictionary extensions&quot;
// ]
</code></pre><p>这样，我们就用record11生成了一个Dictionary&lt;String, String&gt;类型的对象。</p>
<h3 id="为自定义类型实现Hashable-Key"><a href="#为自定义类型实现Hashable-Key" class="headerlink" title="为自定义类型实现Hashable Key"></a>为自定义类型实现Hashable Key</h3><p>本质上来说，Dictionary是一个哈希表，它所有的key都用各自的哈希值保存在一个数组里。因此，通过key在Dictionary中访问value是一个O(1)操作。但这也对key的类型做出了一个要求，<strong>它必须可以计算哈希值</strong>。Swift标准库中提供的绝大多数类型，例如：Int / Float / Double / String / Bool / Date …等，都满足这个要求，因此我们可以直接拿它们来定义Dictionary。</p>
<p>但如果我们有一个自定义类型Account，表示账号，其中的alias / type / createdAt分别表示账号的别名、类型和注册日期：</p>
<pre><code>struct Account {
    var alias: String
    var type: Int
    var createdAt: Date
}
</code></pre><p>当我们把Account用作key的时候，Swift就会给我们提示下面的错误：Account没有遵从Hashable protocol：</p>
<pre><code>let account11 = Account(alias: &quot;11&quot;, type: 1, createdAt  : Date())
let data:[Account: Int] = [ account11: 1000 ]
</code></pre><h4 id="Conform-to-Hashable-protocol"><a href="#Conform-to-Hashable-protocol" class="headerlink" title="Conform to Hashable protocol"></a>Conform to Hashable protocol</h4><p>如何让自定义类型遵从Hashable protocol呢？第一件要做的事，就是告诉Swift，如何获取一个类型的哈希值，这是通过一个叫hashValue的属性完成的：</p>
<pre><code>extension Account: Hashable {
    var hashValue: Int
}
</code></pre><p>如何计算Account.hashValue呢？有两个最重要的考量，分别是：性能和哈希值在整数范围的分布。因为每当我们要在Dictionary中查询、添加、修改或删除元素的时候，都要计算key的哈希值，如果这个计算过于消耗性能，那么计算哈希值的过程就有可能抵消掉通过key随机访问value带来的O(1)性能提升。</p>
<p>当然，你也不能盲目追求性能而忽视哈希值的整数值分布。说一个最极端的例子，如果你让所有情况计算得到的哈希值都是某个常数：</p>
<pre><code>extension Account: Hashable {
    // A BAD idea
    var hashValue: Int { return 1 }
}
</code></pre><p>这个哈希函数有O(1)的性能，但这样，不同的Account对象就会有不同的哈希值，这叫做Collision。当然，Swift Dictionary可以处理哈希值碰撞的情况，但你要随之付出的代价就是，通过哈希值读取value将从一个O(1)变成一个O(n)算法。因此，让哈希值在整数区间均匀分布也是设计哈希函数很重的考虑。</p>
<p>综上所述，设计一个好的哈希函数并不是一个容易的事情。对于我们来说，可以假设Swift标准库的类型提供的hashValue都满足性能和分布的要求。因此，当我们设计复合类型的哈希值的时候，可以基于这些标准类型的哈希值进行一些“低功耗”运算，例如，对这些值进行异或运算，绝大多数的CPU都对这个操作提供了指令级支持：</p>
<pre><code>extension Account: Hashable {
    var hashValue: Int {
        return alias.hashValue ^
                        type.hashValue ^
                        createdAt.hashValue
    }
}
</code></pre><p>解决了Account的哈希值之后，Swift会继而提示我们：<strong>Account没有遵从Equatable protocol</strong>。为什么还要遵从Equatable呢？这是因为哈希函数还有一个很重要的性质：<strong>两个相等对象的哈希值必须是相同的</strong>。因此，我们必须要解决什么叫做两个相等的对象，然后才有比较它们各自哈希值的事情。</p>
<p>Equatable只有一个约束，就是为自定义类型实现==操作符：</p>
<pre><code>extension Account: Equatable {
    static func == (lhs: Account, rhs: Account) -&gt; Bool {
        return lhs.alias == rhs.alias &amp;&amp;
                lhs.type == rhs.type &amp;&amp;
                lhs.createdAt == rhs.createdAt
    }
}
</code></pre><p>在Swift里，运算符必须要定义成static方法，它的两个参数lhs / rhs则表示==两边的操作数。我们判断Account相等的方式很简单，只要它们每一个属性相等，则两个Account对象就是相等的。</p>
<p>当我们让Account遵从了Equatable之后，Swift编译器就不会再报错了。此时，我们在一开始创建的data也可以正常工作了。</p>
<h4 id="Bitwise-rotation"><a href="#Bitwise-rotation" class="headerlink" title="Bitwise rotation"></a>Bitwise rotation</h4><p>我们上面例子中提到的把所有属性进行XOR运算的方法，虽然简单高效，但也有一个问题，就是比较容易造成碰撞。因为XOR运算是可交换的，也就是说a ^ b == b ^ a，因此，如果一个自定义类型中，有多个类型相同属性的时候，就会增大哈希值发生碰撞的概率，因此，我们可以用下面的代码，对其中的一些基础属性的哈希值进行按位旋转后再进行XOR运算：</p>
<pre><code>struct Account {
    let INT_BIT = (Int)(CHAR_BIT) * MemoryLayout&lt;Int&gt;.size

    func bitwiseRotate(value: Int, bits: Int) -&gt; Int {
        return (((value) &lt;&lt; bits) | ((value) &gt;&gt; (UINT_BIT - bits)))
    }
}

extension Account: Hashable {
    var hashValue: Int {
        return bitwiseRotate(value: alias.hashValue, bits: 10) ^
                type.hashValue ^
                createdAt.hashValue
    }
}
</code></pre><p>首先，我们在Account中添加了一个常量INT_BIT表示一个整数的位数。其次，定义了一个辅助方法bitwiseRotate(value:bits:)，它用于先把value向左移动bits位，再向右移动(UINT_BIT - bits)位。</p>
<p>有了这个方法之后，我们就可以在计算哈希值的时候，对其中的属性进行按位旋转了。</p>
<h4 id="警惕引用类型的Key"><a href="#警惕引用类型的Key" class="headerlink" title="警惕引用类型的Key"></a>警惕引用类型的Key</h4><p>和Dictionary.Key相关的最后一个内容，是 <strong>尽可能避免使用引用类型作为key</strong>，这通常会给你带来不必要的麻烦。当一个引用类型作为key之后，当引用类型的对象在Dictionary之外被修改的时候，Key的内容也会随之修改。这样你就再也无法获得之前的哈希值，也就无法获得对应的value了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/29/Filter:Reduce:FlatMap/" rel="next" title="Filter / Reduce / FlatMap的实现和扩展">
                <i class="fa fa-chevron-left"></i> Filter / Reduce / FlatMap的实现和扩展
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/09/Swift中的函数/" rel="prev" title="Swift 中的函数">
                Swift 中的函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="pengyw" />
          <p class="site-author-name" itemprop="name">pengyw</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dictionary基础知识"><span class="nav-number">1.</span> <span class="nav-text">Dictionary基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义Dictionary"><span class="nav-number">1.1.</span> <span class="nav-text">定义Dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用的基本属性"><span class="nav-number">1.2.</span> <span class="nav-text">常用的基本属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加、更新和删除元素"><span class="nav-number">1.3.</span> <span class="nav-text">添加、更新和删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历Dictionary"><span class="nav-number">1.4.</span> <span class="nav-text">遍历Dictionary</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的Dictionary-extension"><span class="nav-number">2.</span> <span class="nav-text">常用的Dictionary extension</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#merge"><span class="nav-number">2.1.</span> <span class="nav-text">merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用一个tuple数组初始化Dictionary"><span class="nav-number">2.2.</span> <span class="nav-text">用一个tuple数组初始化Dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定制map的行为"><span class="nav-number">2.3.</span> <span class="nav-text">定制map的行为</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为自定义类型实现Hashable-Key"><span class="nav-number">3.</span> <span class="nav-text">为自定义类型实现Hashable Key</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Conform-to-Hashable-protocol"><span class="nav-number">3.1.</span> <span class="nav-text">Conform to Hashable protocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bitwise-rotation"><span class="nav-number">3.2.</span> <span class="nav-text">Bitwise rotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#警惕引用类型的Key"><span class="nav-number">3.3.</span> <span class="nav-text">警惕引用类型的Key</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pengyw</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
